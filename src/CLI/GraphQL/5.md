# Configurer les règles d'autorisation

## @auth

L'autorisation est nécessaire pour que les applications puissent interagir avec votre API GraphQL. Les **clés API** sont utilisées de préférence pour les API publiques (ou les parties de votre schéma que vous souhaitez rendre publiques) ou pour le prototypage, et vous devez spécifier le délai d'expiration avant le déploiement. L'autorisation **IAM** utilise [Signature Version 4](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) pour faire des demandes avec les politiques attachées aux rôles. Les jetons OIDC fournis par **Amazon Cognito User Pools** ou par des fournisseurs OpenID Connect tiers peuvent également être utilisés pour l'autorisation, et le simple fait d'activer cette fonction fournit un contrôle d'accès simple exigeant que les utilisateurs s'authentifient pour obtenir un accès de haut niveau aux actions de l'API. Vous pouvez définir des contrôles d'accès plus fins en utilisant `@auth` sur votre schéma qui exploite les métadonnées d'autorisation fournies dans le cadre de ces jetons ou définies sur les éléments de base de données eux-mêmes.

Les types d'objets `@auth` qui sont annotés avec `@auth` sont protégés par un ensemble de règles d'autorisation vous donnant des contrôles supplémentaires par rapport à l'autorisation de haut niveau sur une API. Vous pouvez utiliser la directive `@auth` sur les définitions de types d'objets et les définitions de champs dans le schéma de votre projet.

Lorsque vous utilisez la directive `@auth` sur des définitions de type d'objet qui sont également annotées avec `@model`, tous les résolveurs qui retournent des objets de ce type seront protégés. Lorsque vous utilisez la directive `@auth` sur une définition de champ, un résolveur sera ajouté au champ qui autorise l'accès en fonction des attributs trouvés dans le type parent.

### Definition

```graphql
# Lorsqu'il est appliqué à un type, il ajoute à l'application des règles d'autorisation basées sur le propriétaire et le groupe.
# des règles d'autorisation basées sur le propriétaire et le groupe.
directive @auth(rules: [AuthRule!]!) on OBJECT | FIELD_DEFINITION
input AuthRule {
  allow: AuthStrategy!
  provider: AuthProvider
  ownerField: String # defaults to "owner" when using owner auth
  identityClaim: String # defaults to "username" when using owner auth
  groupClaim: String # defaults to "cognito:groups" when using Group auth
  groups: [String] # Required when using Static Group auth
  groupsField: String # defaults to "groups" when using Dynamic Group auth
  operations: [ModelOperation] # Required for finer control
  # The following arguments are deprecated. It is encouraged to use the 'operations' argument.
  queries: [ModelQuery]
  mutations: [ModelMutation]
}
enum AuthStrategy {
  owner
  groups
  private
  public
}
enum AuthProvider {
  apiKey
  iam
  oidc
  userPools
}
enum ModelOperation {
  create
  update
  delete
  read
}

# The following objects are deprecated. It is encouraged to use ModelOperations.
enum ModelQuery {
  get
  list
}
enum ModelMutation {
  create
  update
  delete
}
```

> Note : L'argument operations a été ajouté pour remplacer les arguments 'queries' et 'mutations'. Les arguments 'queries' et 'mutations' continueront à fonctionner mais il est encouragé de passer à 'operations'. Si les deux sont fournis, l'argument 'operations' est prioritaire sur 'queries'.

### Autorisation du propriétaire

Par défaut, l'activation de l'autorisation `propriétaire` permet à tout utilisateur connecté de créer des enregistrements.

```graphql
# The simplest case
type Post @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  title: String!
}

# The long form way
type Post
  @model
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "owner"
        operations: [create, update, delete, read]
      }
    ]
  ) {
  id: ID!
  title: String!
  owner: String
}
```

L'autorisation du propriétaire exige que le type d'authentification **Amazon Cognito User Pools** soit activé dans votre application.

L'autorisation du propriétaire spécifie si un utilisateur peut accéder ou opérer sur un objet. Pour ce faire, chaque objet obtiendra un champ `ownerField` (par défaut `owner` sera ajouté à l'objet s'il n'est pas spécifié) qui stocke les informations de propriété et est vérifié de différentes manières pendant l'exécution du résolveur.

Vous pouvez utiliser l'argument `operations` pour spécifier quelles opérations sont activées comme suit :

- **read** : Permet à l'utilisateur d'effectuer des requêtes (opérations `get` et `list`) contre l'API.
- **create** : Injecte automatiquement l'identité de l'utilisateur connecté en tant que `ownerField`.
- **update** : Ajouter une mise à jour conditionnelle qui vérifie que le `ownerField` stocké est le même que l'utilisateur connecté.
- **suppression** : Ajouter une mise à jour conditionnelle qui vérifie que le `ownerField` stocké est le même que l'utilisateur connecté.

Vous devez vous assurer que la règle d'opérations `create` est spécifiée explicitement ou déduite des valeurs par défaut pour garantir que l'identité du propriétaire est stockée avec l'enregistrement afin qu'elle puisse être vérifiée lors de demandes ultérieures.

```graphql
# L'identité du propriétaire est déduite des valeurs par défaut de chaque objet.
type Post @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  title: String!
}

# identité du propriétaire spécifiée explicitement sur chaque objet
type Post @model @auth(rules: [{ allow: owner, operations: [create] }]) {
  id: ID!
  title: String!
}

# identité du propriétaire non stockée sur les objets
type Post @model @auth(rules: [{ allow: owner, operations: [read] }]) {
  id: ID!
  title: String!
}
```

Lorsque vous spécifiez des opérations dans le cadre de la règle `@auth`, les opérations non incluses dans la liste ne sont pas protégées par défaut.

Voyons quelques exemples :

```graphql
type Todo @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  updatedAt: AWSDateTime!
  content: String!
}
```

Dans ce schéma, seul le propriétaire de l'objet a l'autorisation d'effectuer des opérations de lecture (`getTodo` et `listTodos`), de mise à jour (`updateTodo`) et de suppression (`deleteTodo`) sur l'objet créé par le propriétaire. Ceci empêche l'objet d'être mis à jour ou supprimé par des utilisateurs autres que le créateur de l'objet.

Voici un tableau décrivant quels utilisateurs sont autorisés à exécuter quelles opérations. **Propriétaire** fait référence à l'utilisateur qui a créé l'objet, **autres** fait référence à tous les autres utilisateurs authentifiés.

|       | getTodo | listTodo | createTodo | updateTodo | deleteTodo |
| ----- | ------- | -------- | ---------- | ---------- | ---------- |
| owner | ✅      | ✅       | ✅         | ✅         | ✅         |
| other | ❌      | ❌       | ✅         | ❌         | ❌         |

Ensuite, supposons que vous souhaitiez modifier le schéma pour que seul le propriétaire de l'objet puisse le mettre à jour ou le supprimer, mais que tout utilisateur authentifié puisse lire les objets.

```graphql
type Todo
  @model
  @auth(rules: [{ allow: owner, operations: [create, delete, update] }]) {
  id: ID!
  updatedAt: AWSDateTime!
  content: String!
}
```

Dans ce schéma, seul le propriétaire de l'objet a l'autorisation d'effectuer des opérations de mise à jour (`updateTodo`) et de suppression (`deleteTodo`) sur l'objet créé par le propriétaire, mais tout le monde peut les lire (`getTodo`, `listTodos`). Cela empêche la mise à jour ou la suppression de l'objet par des utilisateurs autres que le créateur de l'objet tout en permettant à tous les utilisateurs authentifiés de l'application de les lire.

Voici un tableau décrivant quels utilisateurs sont autorisés à exécuter quelles opérations. **Propriétaire** fait référence à l'utilisateur qui a créé l'objet, **autres** fait référence à tous les autres utilisateurs authentifiés.

|       | getTodo | listTodo | createTodo | updateTodo | deleteTodo |
| ----- | ------- | -------- | ---------- | ---------- | ---------- |
| owner | ✅      | ✅       | ✅         | ✅         | ✅         |
| other | ✅      | ✅       | ✅         | ❌         | ❌         |

Ensuite, supposons que vous souhaitiez modifier le schéma pour que seul le propriétaire de l'objet puisse le supprimer, mais que tout le monde puisse le créer, le lire et le mettre à jour.

```graphql
type Todo
  @model
  @auth(rules: [{ allow: owner, operations: [create, delete] }]) {
  id: ID!
  updatedAt: AWSDateTime!
  content: String!
}
```

Dans ce schéma, seul le propriétaire de l'objet a l'autorisation d'effectuer des opérations de suppression sur l'objet créé par le propriétaire, mais tout le monde peut les lire ou les mettre à jour. C'est parce que `read` et `update` ne sont pas spécifiés comme des actions réservées au propriétaire, donc tous les utilisateurs sont capables de les exécuter. Comme `delete` est spécifié comme une action réservée au propriétaire, seul le créateur de l'objet peut le supprimer.

Voici un tableau décrivant quels utilisateurs sont autorisés à exécuter quelles opérations. **Propriétaire** fait référence à l'utilisateur qui a créé l'objet, **autres** fait référence à tous les autres utilisateurs authentifiés.
| | getTodo | listTodo | createTodo | updateTodo | deleteTodo |
|--|--|--|--|--|--|
| owner | ✅|✅ | ✅ | ✅ | ✅ |
| other | ✅ | ✅ | ✅ | ✅ | ❌ |

### Règles d'autorisation multiples

Vous pouvez également appliquer plusieurs règles d'autorisation sur un seul type `@model`.

Par exemple, imaginez que vous avez un type **Draft** qui stocke les articles inachevés d'un blog. Vous pourriez vouloir autoriser le propriétaire du **Brouillon** à "créer", "mettre à jour", "supprimer" et "lire" les objets **Brouillon**. Cependant, vous pourriez aussi vouloir que les rédacteurs de **Draft** puissent mettre à jour et lire les objets **Draft**.

Pour prendre en compte ce cas d'utilisation, vous pouvez utiliser la définition de type suivante :

```graphql
type Draft
  @model
  @auth(
    rules: [
      # Defaults to use the "owner" field.
      { allow: owner }
      # Authorize the update mutation and both queries.
      { allow: owner, ownerField: "editors", operations: [update, read] }
    ]
  ) {
  id: ID!
  title: String!
  content: String
  owner: String
  editors: [String]
}
```

### Propriété avec mutations de création

La règle d'autorisation de propriété remplira automatiquement les champs de propriété à moins qu'on ne lui dise explicitement de ne pas le faire. Pour montrer comment cela fonctionne, regardons comment la mutation create fonctionnerait pour le type **Draft** ci-dessus :

```graphql
mutation CreateDraft {
  createDraft(input: { title: "A new draft" }) {
    id
    title
    owner
    editors
  }
}
```

Supposons que lorsque j'appelle cette mutation, je suis connecté en tant que `someuser@my-domain.com`. Le résultat serait :

```json
{
  "data": {
    "createDraft": {
      "id": "...",
      "title": "A new draft",
      "owner": "someuser@my-domain.com",
      "editors": null
    }
  }
}
```

Le résolveur `Mutation.createDraft` est suffisamment intelligent pour faire correspondre vos règles d'authentification aux attributs et les remplit par défaut.

Pour spécifier une liste de **éditeurs**, vous pouvez exécuter ceci :

```graphql
mutation CreateDraft {
  createDraft(
    input: {
      title: "A new draft"
      editors: ["editor1@my-domain.com", "editor2@my-domain.com"]
    }
  ) {
    id
    title
    owner
    editors
  }
}
```

Cela reviendrait :

```json
{
  "data": {
    "createDraft": {
      "id": "...",
      "title": "A new draft",
      "owner": "someuser@my-domain.com",
      "editors": ["editor1@my-domain.com", "editor2@my-domain.com"]
    }
  }
}
```

Vous pouvez essayer d'effectuer une modification de **owner** mais cela déclenchera une exception **Unauthorized** car vous n'êtes plus le propriétaire de l'objet que vous essayez de créer.

```graphql
mutation CreateDraft {
  createDraft(input: { title: "A new draft", editors: [], owner: null }) {
    id
    title
    owner
    editors
  }
}
```

### Autorisation de groupe statique

L'autorisation par groupe statique vous permet de protéger les types de `@model` en limitant l'accès à un ensemble connu de groupes. Par exemple, vous pouvez autoriser tous les utilisateurs **Admin** à créer, mettre à jour, supprimer, obtenir et lister les objets Salary.

```graphql
type Salary @model @auth(rules: [{ allow: groups, groups: ["Admin"] }]) {
  id: ID!
  wage: Int
  currency: String
}
```

Lorsque vous appelez l'API GraphQL, si l'identifiant de l'utilisateur (tel que spécifié par `$ctx.identity` du résolveur) n'est pas inscrit dans le groupe _Admin_, l'opération échouera.

Pour permettre des cas d'utilisation d'autorisation avancés, vous pouvez superposer des règles d'authentification pour fournir une fonctionnalité spécialisée. Pour montrer comment vous pouvez le faire, développons l'exemple **Draft** que vous avez commencé dans la section **Owner Authorization** ci-dessus. Lorsque vous vous êtes quitté, un objet **Draft** pouvait être mis à jour et lu à la fois par son propriétaire et par n'importe lequel de ses éditeurs, et pouvait être créé et supprimé uniquement par son propriétaire. Changeons cela de façon à ce que tout membre du groupe "Admin" puisse également créer, mettre à jour, supprimer et lire un objet **Draft**.

```graphql
type Draft
  @model
  @auth(
    rules: [
      # Par défaut, le champ "propriétaire" est utilisé.
      { allow: owner }
      # Autoriser la mutation de la mise à jour et les deux requêtes.
      { allow: owner, ownerField: "editors", operations: [update] }
      # Les utilisateurs Admin peuvent accéder à n'importe quelle opération.
      { allow: groups, groups: ["Admin"] }
    ]
  ) {
  id: ID!
  title: String!
  content: String
  owner: String
  editors: [String]!
}
```

### Autorisation dynamique des groupes

```graphql
# Autorisation dynamique de groupe avec plusieurs groupes
type Post @model @auth(rules: [{ allow: groups, groupsField: "groups" }]) {
  id: ID!
  title: String
  groups: [String]
}

# Autorisation dynamique de groupe avec un seul groupe
type Post @model @auth(rules: [{ allow: groups, groupsField: "group" }]) {
  id: ID!
  title: String
  group: String
}copy
```

Avec l'autorisation dynamique de groupe, chaque enregistrement contient un attribut spécifiant quels groupes doivent pouvoir y accéder. Utilisez l'argument _groupsField_ pour indiquer quel attribut du magasin de données sous-jacent contient ces informations de groupe. Pour spécifier qu'un seul groupe doit avoir accès, utilisez un champ de type `String`. Pour indiquer que plusieurs groupes doivent avoir accès, utilisez un champ de type `[String]`.

Comme pour les autres règles d'authentification, vous pouvez superposer des règles de groupe dynamique à d'autres règles. Développons à nouveau l'exemple **Draft** des sections **Autorisation du propriétaire** et **Autorisation statique du groupe** ci-dessus. La dernière fois que nous nous sommes quittés, les éditeurs pouvaient mettre à jour et lire les objets, les propriétaires avaient un accès complet et les membres du groupe administrateur avaient un accès complet aux objets **Draft**. Maintenant, vous avez une nouvelle exigence où chaque enregistrement devrait être en mesure de spécifier une liste facultative de groupes qui peuvent lire le projet. Cela vous permettrait de partager un document individuel avec une équipe externe, par exemple.

```graphql
type Draft
  @model
  @auth(
    rules: [
      # Par défaut, le champ "owner" est utilisé.
      { allow: owner }
      # Autorise la mutation de la mise à jour et les deux requêtes.
      { allow: owner, ownerField: "editors", operations: [update] }
      # Les utilisateurs de l'administration peuvent accéder à toutes les opérations.
      { allow: groups, groups: ["Admin"] }
      # Chaque enregistrement peut spécifier quels groupes peuvent le lire.
      { allow: groups, groupsField: "groupsCanAccess", operations: [read] }
    ]
  ) {
  id: ID!
  title: String!
  content: String
  owner: String
  editors: [String]!
  groupsCanAccess: [String]!
}
```

Avec cette configuration, vous pouvez créer un objet qui peut être lu par le groupe "BizDev" :

```graphql
mutation CreateDraft {
  createDraft(
    input: { title: "A new draft", editors: [], groupsCanAccess: ["BizDev"] }
  ) {
    id
    groupsCanAccess
  }
}
```

Et un autre projet qui peut être lu par le groupe "Marketing" :

```graphql
mutation CreateDraft {
  createDraft(
    input: {
      title: "Another draft"
      editors: []
      groupsCanAccess: ["Marketing"]
    }
  ) {
    id
    groupsCanAccess
  }
}
```

### `public` authorization

```graphql
12345# The simplest case
type Post @model @auth(rules: [{ allow: public }]) {
  id: ID!
  title: String!
}
```

L'autorisation `public` spécifie que tout le monde sera autorisé à accéder à l'API. En coulisses, l'API sera protégée par une clé d'API. Pour pouvoir utiliser `public`, l'API doit avoir une clé d'API configurée. Pour une exécution locale, cette clé réside dans le fichier `aws-exports.js` pour la bibliothèque JavaScript et `amplifyconfiguration.json` pour Android et iOS sous la clé `aws_appsync_apiKey`.

```graphql
# autorisation publique avec remplacement du fournisseur
type Post @model @auth(rules: [{ allow: public, provider: iam }]) {
  id: ID!
  title: String!
}copy
```

La directive `@auth` permet de remplacer le fournisseur par défaut pour un mode d'autorisation donné. Dans l'exemple ci-dessus, `iam` est spécifié comme le fournisseur qui vous permet d'utiliser un "rôle non authentifié" à partir des pools d'identité Cognito pour l'accès public au lieu d'une clé API. Lorsqu'il est utilisé en conjonction avec amplify add auth, le CLI génère automatiquement des politiques IAM descendantes pour le rôle "UnAuthenticated".

### `private` authorization

```graphql
# The simplest case
type Post @model @auth(rules: [{ allow: private }]) {
  id: ID!
  title: String!
}
```

L'autorisation `private` spécifie que tout le monde sera autorisé à accéder à l'API avec un jeton JWT valide provenant du pool d'utilisateurs Cognito configuré. Pour pouvoir utiliser `private`, l'API doit avoir un pool d'utilisateurs Cognito configuré.

```graphql
# autorisation privée avec remplacement du fournisseur
type Post @model @auth(rules: [{ allow: private, provider: iam }]) {
  id: ID!
  title: String!
}
```

La directive `@auth` permet de remplacer le fournisseur par défaut pour un mode d'autorisation donné. Dans l'exemple ci-dessus, `iam` est spécifié comme le fournisseur qui vous permet d'utiliser un "rôle authentifié" de Cognito Identity Pools pour l'accès privé. Lorsqu'il est utilisé en conjonction avec amplify add auth, le CLI génère automatiquement des politiques IAM descendantes pour le rôle "Authentifié".

### Autorisation utilisant un fournisseur `oidc'.

```graphql
# autorisation du propriétaire avec dérogation du fournisseur
type Profile
  @model
  @auth(rules: [{ allow: owner, provider: oidc, identityClaim: "sub" }]) {
  id: ID!
  displayNAme: String!
}
```

En utilisant un fournisseur `oidc` configuré pour l'API, il est possible d'authentifier les utilisateurs par rapport à celle-ci. Dans l'exemple ci-dessus, `oidc` est spécifié comme fournisseur pour l'autorisation `owner` sur le type. Le champ `identityClaim : "sub"` spécifie que la revendication `"sub"` de votre jeton JWT est utilisée pour le fournisseur de propriété au lieu de la revendication par défaut `username`, qui est utilisée par le JWT Amazon Cognito.

### Combinaison de plusieurs types d'autorisation

Les API GraphQL d'Amplify ont un type d'authentification primaire **par défaut** et, éventuellement, des types d'authentification secondaires supplémentaires. Les objets et les champs du schéma GraphQL peuvent se voir attribuer des règles avec différents fournisseurs d'autorisation en fonction des types d'authentification configurés dans votre application.

L'un des scénarios les plus courants pour les règles d'autorisation multiples consiste à combiner l'accès public et privé. Par exemple, les blogs autorisent généralement l'accès public à la consultation d'un article, mais ne permettent qu'à son créateur de le mettre à jour ou de le supprimer.

Voyons comment vous pouvez combiner l'accès public et privé pour y parvenir :

```graphql
type Post
  @model
  @auth(
    rules: [
      # permettre à tous les utilisateurs authentifiés de créer des messages
      # Permettre aux propriétaires de mettre à jour et de supprimer leurs articles.
      { allow: owner }
      # permettre à tous les utilisateurs authentifiés de lire les messages
      { allow: private, operations: [read] }
      # permettre à tous les utilisateurs invités (non authentifiés) de lire les messages
      { allow: public, operations: [read] }
    ]
  ) {
  id: ID!
  title: String
  owner: String
}
```

Le schéma ci-dessus suppose une combinaison de types d'authentification **Amazon Cognito User Pools** et **API key**.

Regardons un autre exemple. Ici, le modèle `Post` est protégé par Cognito User Pools par défaut et le `owner` peut effectuer toute opération sur le type `Post`. Vous pouvez également appeler `getPosts` et `listPosts` depuis une fonction AWS Lambda si elle est configurée avec les politiques IAM appropriées dans son rôle d'exécution.

```graphql
type Post
  @model
  @auth(
    rules: [
      { allow: owner }
      { allow: private, provider: iam, operations: [read] }
    ]
  ) {
  id: ID!
  title: String
  owner: String
}
```

Le schéma ci-dessus suppose une combinaison de types d'authentification **Amazon Cognito User Pools** et **IAM**.

### Combinaisons de modes d'autorisation et de fournisseurs autorisées

Le tableau suivant indique les combinaisons autorisées de modes d'autorisation et de fournisseurs.

|           | owner | groups | public | private |
| --------- | ----- | ------ | ------ | ------- |
| userPools | ✅    | ✅     |        | ✅      |
| oidc      | ✅    | ✅     |        |         |
| apiKey    |       |        | ✅     |         |
| iam       |       |        | ✅     | ✅      |

Veuillez noter que `groups` utilise les pools d'utilisateurs de Cognito mais qu'il n'est pas nécessaire/possible d'assigner des fournisseurs.

### Réclamations personnalisées

`@auth` supporte l'utilisation de revendications personnalisées si vous ne souhaitez pas utiliser les revendications par défaut `username` ou `cognito:groups` de votre jeton JWT qui sont remplies par Amazon Cognito. Cela peut être utile si vous utilisez des jetons d'un système OIDC tiers ou si vous souhaitez remplir une réclamation avec une liste de groupes d'un système externe, comme lorsque vous utilisez un [Pre Token Generation Lambda Trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html) qui lit depuis une base de données. Pour utiliser des revendications personnalisées, spécifiez `identityClaim` ou `groupClaim` comme il convient, comme dans l'exemple ci-dessous :

```graphql
type Post
  @model
  @auth(
    rules: [
      { allow: owner, identityClaim: "user_id" }
      { allow: groups, groups: ["Moderator"], groupClaim: "user_groups" }
    ]
  ) {
  id: ID!
  owner: String
  postname: String
  content: String
}
```

Dans cet exemple, le propriétaire de l'objet vérifiera une réclamation `user_id`. Veuillez noter que cette réclamation n'est pas disponible par défaut si le jeton est généré par Cognito. Utilisez `sub` à la place si vous utilisez un jeton généré par Cognito. De même, si le claim `user_groups` contient une chaîne "Moderator", l'accès sera accordé.

Notez que `identityField` n'est plus utilisé pour `identityClaim`.

### Autorisation des abonnements

Avant la version 2.0 du CLI, les règles `@auth` ne s'appliquaient pas aux abonnements. Vous deviez soit les désactiver, soit utiliser [Custom Resolvers](https://docs.amplify.aws/cli/graphql-transformer/resolvers#custom-resolvers) pour ajouter manuellement des contrôles d'autorisation. Dans les dernières versions, les protections `@auth` ont été ajoutées aux abonnements, cependant cela peut introduire un comportement différent dans les applications existantes : Premièrement, `owner` est maintenant un argument obligatoire pour l'autorisation basée sur le propriétaire, comme indiqué ci-dessous. Deuxièmement, l'ensemble de sélection sera `null` sur les champs lorsque les mutations sont invoquées si `@auth` par champ est défini sur ce champ. Pour en savoir plus, cliquez ici. Si vous souhaitez conserver le comportement précédent, définissez `level : public` sur votre modèle comme défini ci-dessous.

Lorsque `@auth` est utilisé, les abonnements ont quelques différences de comportement subtiles par rapport aux requêtes et aux mutations, en raison de leur nature événementielle. Lorsque vous protégez un modèle à l'aide de la stratégie d'authentification du propriétaire, chaque demande d'abonnement **exige** que l'utilisateur soit transmis comme argument à la demande d'abonnement. Si le champ utilisateur n'est pas transmis, la connexion d'abonnement échouera. Dans le cas où il est passé, l'utilisateur sera uniquement notifié des mises à jour des enregistrements dont il est le propriétaire.

Le filtrage de l'abonnement utilise les données transmises par la mutation pour effectuer le filtrage. Si une mutation n'inclut pas le champ `owner` dans l'ensemble de sélection d'une authentification basée sur le propriétaire, le message d'abonnement ne sera pas déclenché pour cette mutation.

Par ailleurs, lorsque le modèle est protégé par la stratégie d'authentification par groupe statique, la demande d'abonnement n'aboutira que si l'utilisateur fait partie d'un groupe autorisé. En outre, l'utilisateur ne recevra des notifications de mise à jour des enregistrements que s'il fait partie d'un groupe autorisé. Remarque : il n'est pas nécessaire de transmettre l'utilisateur comme argument dans la demande d'abonnement, car le résolveur vérifiera le contenu de votre jeton JWT.

Les groupes dynamiques n'ont aucun impact sur les abonnements. Vous ne serez pas informé de leurs mises à jour.

Par exemple, supposons que vous ayez le schéma suivant :

```graphql
type Post @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  owner: String
  postname: String
  content: String
}
```

Cela signifie que l'abonnement doit ressembler à ce qui suit, sinon il échouera :

```graphql
subscription OnCreatePost {
  onCreatePost(owner: “Bob”){
    postname
    content
  }
}
```

Notez que si votre type n'a pas déjà un champ `owner`, le Transformer l'ajoutera automatiquement pour vous. Passer l'utilisateur actuel peut être fait dynamiquement dans votre code en utilisant [Auth.currentAuthenticatedUser()](https://docs.amplify.aws/lib/auth/manageusers/q/platform/js#retrieve-current-authenticated-user) en JavaScript, [AWSMobileClient.default().username](https://docs.amplify.aws/sdk/auth/working-with-api/q/platform/ios#utility-properties) en iOS, ou [AWSMobileClient.getInstance().getUsername()](https://docs.amplify.aws/sdk/auth/working-with-api/q/platform/android#utility-properties) en Android.

Dans le cas des groupes, si vous définissez ce qui suit :

```graphql
type Post @model @auth(rules: [{ allow: groups, groups: ["Admin"] }]) {
  id: ID!
  owner: String
  postname: String
  content: String
}
```

Dans ce cas, vous n'avez pas besoin de passer un argument, car le résolveur vérifiera le contenu de votre jeton JWT au moment de la souscription et s'assurera que vous faites partie du groupe "Admin".

Enfin, si vous utilisez à la fois l'autorisation du propriétaire et du groupe, l'argument du nom d'utilisateur devient facultatif. Cela signifie ce qui suit :

- Si vous ne passez pas l'utilisateur, mais que vous êtes membre d'un groupe autorisé, l'abonnement vous notifiera les enregistrements ajoutés.
- Si vous ne passez pas l'utilisateur, mais que vous n'êtes PAS membre d'un groupe autorisé, l'abonnement échouera à se connecter.
- Si vous transmettez l'utilisateur qui EST le propriétaire mais qui n'est PAS membre d'un groupe, l'abonnement vous informera des enregistrements ajoutés dont vous êtes le propriétaire.
- Si vous introduisez un utilisateur qui n'est PAS le propriétaire et qui n'est PAS membre d'un groupe, l'abonnement ne vous informera de rien car il n'y a pas d'enregistrements dont vous êtes le propriétaire.

Vous pouvez désactiver les contrôles d'autorisation sur les abonnements ou désactiver complètement les abonnements en spécifiant soit `public` soit `off` dans `@model` :

```graphql
@model (subscriptions: { level: public })
```

### Autorisation au niveau du champ

La directive `@auth` spécifie que l'accès à un champ spécifique doit être restreint en fonction de son propre ensemble de règles. Voici quelques situations où cela est utile :

**Protéger l'accès à un champ qui a des permissions différentes de celles du modèle parent**.

Vous pouvez avoir un modèle d'utilisateur dans lequel certains champs, comme _username_, font partie du profil public et le champ _ssn_ est visible pour les propriétaires.

```graphql
type User @model {
  id: ID!
  username: String
  ssn: String @auth(rules: [{ allow: owner, ownerField: "username" }])
}
```

**Protéger l'accès à un résolveur `@connection` en se basant sur un attribut de l'objet source**.

Ce schéma protégera l'accès aux objets Post connectés à un utilisateur en se basant sur un attribut du modèle User. Vous pouvez désactiver les requêtes de haut niveau en spécifiant `queries : null` dans la déclaration `@model` qui restreint l'accès de telle sorte que les requêtes doivent passer par les résolveurs `@connection` pour atteindre le modèle.

```graphql
type User @model {
  id: ID!
  username: String
  posts: [Post]
    @connection(name: "UserPosts")
    @auth(rules: [{ allow: owner, ownerField: "username" }])
}
type Post @model(queries: null) { ... }
```

**Protéger les mutations de telle sorte que certains champs puissent avoir des règles d'accès différentes de celles du modèle parent**.

Lorsqu'elles sont utilisées sur des définitions de champs, les directives `@auth` protègent toutes les opérations par défaut. Pour protéger les opérations de lecture, un résolveur est ajouté au champ protégé qui implémente la logique d'autorisation. Pour protéger les opérations de mutation, une logique est ajoutée aux mutations existantes qui seront exécutées si l'entrée de la mutation contient le champ protégé. Par exemple, voici un modèle où les propriétaires et les administrateurs peuvent lire les salaires des employés mais où seuls les administrateurs peuvent les créer ou les mettre à jour.

```graphql
type Employee @model {
  id: ID!
  email: String
  username: String

  # Les propriétaires et les membres du groupe "Admin" peuvent lire les salaires des employés.
  # Seuls les membres du groupe "Admin" peuvent créer un employé avec un salaire.
  # ou mettre à jour un salaire.
  salary: String
    @auth(
      rules: [
        { allow: owner, ownerField: "username", operations: [read] }
        { allow: groups, groups: ["Admin"], operations: [create, update, read] }
      ]
    )
}
```

\*\*Remarque : L'opération "delete", lorsqu'elle est utilisée dans les directives "`@auth`" sur les définitions de champ, se traduit par la protection de la mutation de mise à jour de telle sorte que le champ ne puisse pas être mis à zéro sans autorisation.

**Note:** Lorsque vous spécifiez des opérations dans le cadre de la règle `@auth` sur un champ, les opérations non incluses dans la liste des opérations ne sont pas protégées par défaut. Par exemple, disons que vous avez le schéma suivant :

```graphql
type Todo @model {
  id: ID!
  owner: String
  updatedAt: AWSDateTime!
  content: String! @auth(rules: [{ allow: owner, operations: [update] }])
}
```

Dans ce schéma, seul le propriétaire de l'objet a l'autorisation d'effectuer des opérations de mise à jour sur le champ `content`. Mais cela n'empêche pas tout autre propriétaire (tout utilisateur autre que le créateur ou le propriétaire de l'objet) de mettre à jour un autre champ de l'objet appartenant à un autre utilisateur. Si vous voulez empêcher les opérations de mise à jour sur un champ, l'utilisateur devra explicitement ajouter des règles d'authentification pour restreindre l'accès à ce champ. L'une des façons de procéder consiste à spécifier explicitement des règles d'authentification sur les champs que vous souhaitez protéger, comme suit :

```graphql
type Todo @model {
  id: ID!
  owner: String
  updatedAt: AWSDateTime! @auth(rules: [{ allow: owner, operations: [update] }]) // or @auth(rules: [{ allow: groups, groups: ["Admins"] }])
  content: String! @auth(rules: [{ allow: owner, operations: [update] }])
}
```

Vous pouvez également fournir des règles de refus explicites à votre champ, comme suit :

```graphql
type Todo @model {
  id: ID!
  owner: String
  updatedAt: AWSDateTime!
    @auth(
      rules: [{ allow: groups, groups: ["ForbiddenGroup"], operations: [] }]
    )
  content: String! @auth(rules: [{ allow: owner, operations: [update] }])
}
```

Vous pouvez également combiner des règles @auth de haut niveau sur le type avec des règles auth au niveau des champs. Par exemple, considérons le schéma suivant :

```graphql
type Todo
  @model
  @auth(rules: [{ allow: groups, groups: ["Admin"], operations: [update] }]) {
  id: ID!
  owner: String
  updatedAt: AWSDateTime!
  content: String! @auth(rules: [{ allow: owner, operations: [update] }])
}
```

Dans le schéma ci-dessus, les utilisateurs du groupe `Admin` ont l'autorisation de créer, lire, supprimer et mettre à jour (sauf le champ `content` dans l'objet d'un autre propriétaire) pour le type Todo. Un `propriétaire` d'un objet a l'autorisation de créer des types Todo et de lire tous les objets de type Todo. De plus, un `propriétaire` peut effectuer une opération de mise à jour sur l'objet Todo seulement si le champ `content` est présent comme partie de l'entrée. Tout autre utilisateur - qui n'est pas le propriétaire d'un objet - n'est pas autorisé à mettre à jour cet objet.

#### Per-Field avec abonnements

Lorsque vous définissez `@auth` par champ, le Transformer modifiera la réponse des mutations pour ces champs en les mettant à `null` afin d'éviter que des données sensibles soient envoyées via des abonnements. Par exemple dans le schéma ci-dessous :

```graphql
type Employee
  @model
  @auth(rules: [{ allow: owner }, { allow: groups, groups: ["Admins"] }]) {
  id: ID!
  name: String!
  address: String!
  ssn: String @auth(rules: [{ allow: owner }])
}
```

Les abonnés peuvent être membres du groupe "Admins" et devraient être informés du nouvel élément, mais ils ne devraient pas obtenir le champ `ssn`. Si vous exécutez la mutation suivante :

```graphql
mutation {
  createEmployee(
    input: { name: "Nadia", address: "123 First Ave", ssn: "392-95-2716" }
  ) {
    name
    address
    ssn
  }
}
```

La mutation s'exécutera avec succès, mais `ssn` renverra null dans la réponse GraphQL. Cela empêche toute personne du groupe "Admins" qui est abonnée aux mises à jour de recevoir les informations privées. Les abonnés recevront toujours le `name` et l'`address`. Les données sont toujours écrites et cela peut être vérifié en exécutant une requête.

#### Génère

La directive `@auth` ajoutera des extraits d'autorisation à tout modèle de mappage de résolveur pertinent au moment de la compilation. Différentes opérations utilisent différentes méthodes d'autorisation.

**Owner Authorization**

```graphql
type Post @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  title: String!
}
```

Les résolveurs générés seraient protégés comme suit :

- `Mutation.createX` : Vérifie que l'utilisateur demandeur a un justificatif d'identité valide et définit automatiquement l'attribut **owner** comme étant égal à `$ctx.identity.username`.
- `Mutation.updateX` : Mettre à jour l'expression de la condition pour que l'opération DynamoDB `UpdateItem` ne réussisse que si l'attribut **owner** de l'enregistrement est égal à `$ctx.identity.username` de l'appelant.
- `Mutation.deleteX` : Mettre à jour l'expression de la condition pour que l'opération DynamoDB `DeleteItem` ne réussisse que si l'attribut **owner** de l'enregistrement est égal à l'attribut `$ctx.identity.username` de l'appelant.
- `Query.getX` : Dans le modèle de mappage de la réponse, vérifiez que l'attribut **owner** du résultat est le même que le `$ctx.identity.username`. Si ce n'est pas le cas, il retourne `null`.
- `Query.listX` : Dans le modèle de mappage de la réponse, filtrez les **items** du résultat de sorte que seuls les éléments dont l'attribut **owner** est le même que celui de `$ctx.identity.username` soient renvoyés.
- Les résolveurs de `@connexion` : Dans le modèle de mappage des réponses, filtrez les **items** du résultat de manière à ce que seuls les éléments dont l'attribut **owner** est identique à l'attribut `$ctx.identity.username` soient renvoyés. Ceci n'est pas activé lorsque l'on utilise l'argument `queries`.

### Autorisation de groupe statique

```graphql
type Post @model @auth(rules: [{ allow: groups, groups: ["Admin"] }]) {
  id: ID!
  title: String!
  groups: String
}
```

L'authentification par groupe statique est plus simple que les autres. Les résolveurs générés seraient protégés comme suit :

- `Mutation.createX` : Vérifier que l'utilisateur demandeur a une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, échec.
- `Mutation.updateX` : Vérifiez que l'utilisateur demandeur a une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, échec.
- `Mutation.deleteX` : Vérifiez que l'utilisateur demandeur a une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, échouez.
- `Query.getX` : Vérifiez que l'utilisateur demandeur a une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, échouez.
- `Query.listX` : Vérifiez que l'utilisateur demandeur a une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, échouez.
- Résolveurs de `@connexion` : Vérifiez que l'utilisateur demandeur possède une accréditation valide et que `$ctx.identity.claims.get("cognito:groups")` contient le groupe **Admin**. Si ce n'est pas le cas, il faut échouer. Ceci n'est pas activé lorsque vous utilisez l'argument `queries`.

### Autorisation de groupe dynamique

```graphql
type Post @model @auth(rules: [{ allow: groups, groupsField: "groups" }]) {
  id: ID!
  title: String!
  groups: String
}
```

Les résolveurs générés seraient protégés comme suit :

- `Mutation.createX` : Vérifie que l'utilisateur demandeur a un justificatif d'identité valide et qu'il contient une revendication pour au moins un groupe transmis à la requête dans l'argument `$ctx.args.input.groups`.
- `Mutation.updateX` : Mettre à jour l'expression de condition pour que l'opération `UpdateItem` de DynamoDB ne réussisse que si l'attribut **groups** de l'enregistrement contient au moins un des groupes revendiqués par l'appelant via `$ctx.identity.claims.get("cognito:groups")`.
- `Mutation.deleteX` : Mettre à jour l'expression de la condition pour que l'opération DynamoDB `DeleteItem` ne réussisse que si l'attribut **groups** de l'enregistrement contient au moins un des groupes revendiqués par l'appelant via `$ctx.identity.claims.get("cognito:groups")`.
- `Query.getX` : Dans le modèle de mappage de la réponse, vérifiez que l'attribut **groups** du résultat contient au moins un des groupes revendiqués par l'appelant via `$ctx.identity.claims.get("cognito:groups")`.
- `Query.listX` : Dans le modèle de mappage de la réponse, filtrez les **items** du résultat de sorte que seuls les éléments dont l'attribut **groups** contient au moins un des groupes revendiqués par l'appelant via `$ctx.identity.claims.get("cognito:groups")`.
- Le résolveur `@connection` : Dans le modèle de mappage de la réponse, filtrez les **items** du résultat de sorte que seuls les éléments dont l'attribut **groups** contient au moins un des groupes revendiqués par l'appelant via `$ctx.identity.claims.get("cognito:groups")`. Ceci n'est pas activé lorsque vous utilisez l'argument `queries`.
